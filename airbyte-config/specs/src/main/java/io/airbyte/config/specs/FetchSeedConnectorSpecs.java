/*
 * Copyright (c) 2021 Airbyte, Inc., all rights reserved.
 */

package io.airbyte.config.specs;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.databind.JsonNode;
import com.google.cloud.storage.Storage;
import com.google.cloud.storage.StorageOptions;
import io.airbyte.commons.io.IOs;
import io.airbyte.commons.util.MoreIterators;
import io.airbyte.commons.yaml.Yamls;
import io.airbyte.config.Configs;
import io.airbyte.config.EnvConfigs;
import io.airbyte.protocol.models.ConnectorSpecification;
import java.io.IOException;
import java.io.Serializable;
import java.nio.file.Path;
import java.util.List;
import java.util.stream.Collectors;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class FetchSeedConnectorSpecs {

  private static final Logger LOGGER = LoggerFactory.getLogger(FetchSeedConnectorSpecs.class);

  private static final Options OPTIONS = new Options();
  private static final Option SEED_ROOT_OPTION = new Option("o", "seed-root", true, "path to where seed resource files are stored");

  static {
    SEED_ROOT_OPTION.setRequired(true);
    OPTIONS.addOption(SEED_ROOT_OPTION);
  }

  public static void main(final String[] args) throws Exception {
    final CommandLine parsed = parse(args);
    final Path outputRoot = Path.of(parsed.getOptionValue(SEED_ROOT_OPTION.getOpt()));

    final FetchSeedConnectorSpecs fetchSeedConnectorSpecs = new FetchSeedConnectorSpecs();
    fetchSeedConnectorSpecs.run(outputRoot, ConnectorType.SOURCE);
    fetchSeedConnectorSpecs.run(outputRoot, ConnectorType.DESTINATION);
  }

  @JsonPropertyOrder({
      "dockerImage",
      "spec"
  })
  static class DockerImageSpec implements Serializable {

    @JsonProperty("dockerImage")
    private final String dockerImage;
    @JsonProperty("spec")
    private final ConnectorSpecification spec;

    DockerImageSpec(final String dockerImage, final ConnectorSpecification spec) {
      this.dockerImage = dockerImage;
      this.spec = spec;
    }
  }

  public void run(final Path seedRoot, final ConnectorType connectorType) throws IOException {
    System.out.println("Hello from FetchSeedSpecs!");

    final String seedDefinitionsYaml = IOs.readFile(seedRoot, connectorType.getDefinitionFileName());
    final JsonNode seedDefinitionsJson = Yamls.deserialize(seedDefinitionsYaml);
    final List<String> seedDefinitionsDockerImages = MoreIterators.toList(seedDefinitionsJson.elements()).stream()
        .map(json -> String.format("%s:%s", json.get("dockerRepository").asText(), json.get("dockerImageTag").asText()))
        .collect(Collectors.toList());

    System.out.println(seedDefinitionsDockerImages);

    final Storage storage = StorageOptions.getDefaultInstance().getService();
    final Configs configs = new EnvConfigs();
    final String bucketName = configs.getSpecCacheBucket();

    final List<DockerImageSpec> dockerImageSpecs = seedDefinitionsDockerImages.stream()
        .map(dockerImage -> fetchSpecFromGCS(storage, bucketName, dockerImage))
        .collect(Collectors.toList());

    final String outputString = String.format("# This file is generated by %s.\n", this.getClass().getName())
        + "# Do NOT edit this file directly. See generator class for more details.\n"
        + Yamls.serialize(dockerImageSpecs);
    final Path outputPath = IOs.writeFile(seedRoot.resolve(connectorType.getSpecFileName()), outputString);
  }

  private DockerImageSpec fetchSpecFromGCS(final Storage storage, final String bucketName, final String dockerImage) {
    final ConnectorSpecification spec = GcsBucketSpecFetcher.attemptFetch(storage, bucketName, dockerImage)
        .orElseThrow(() -> new RuntimeException(String.format(
            "Failed to fetch valid spec file for docker image %s from GCS bucket %s",
            dockerImage,
            bucketName)));
    return new DockerImageSpec(dockerImage, spec);
  }

  private static CommandLine parse(final String[] args) {
    final CommandLineParser parser = new DefaultParser();
    final HelpFormatter helpFormatter = new HelpFormatter();

    try {
      return parser.parse(OPTIONS, args);
    } catch (final ParseException e) {
      helpFormatter.printHelp("", OPTIONS);
      throw new IllegalArgumentException(e);
    }
  }
}
